% Index
\usepackage{makeidx}

\usepackage{amsmath, amsthm, amssymb, amsfonts}

\usepackage{cool}

% Environments
\newtheorem{definition}{Definition}[section]
\newtheorem{example}{Example}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{proposition}{Proposition}[section]
\newtheorem{theorem}{Theorem}[section]

\newcounter{claimcounter}
\numberwithin{claimcounter}{theorem}
\newenvironment{claim}{\stepcounter{claimcounter}{\emph{Claim \theclaimcounter:}}}{}

% Notation
\newcommand{\abs}[1]{\left|{#1}\right|}
\newcommand{\adj}[1]{{#1}^\star}
\newcommand{\conj}[1]{\overline{#1}}
\newcommand{\dualGroup}[1]{{\widehat{#1}}}
\newcommand{\defeq}{:=}
\newcommand{\dd}{\,\mathrm{d}}
\newcommand{\dimRep}[1]{{d_{#1}}}
\newcommand{\dummy}{\cdot}
\newcommand{\g}{\mathfrak{g}}
\newcommand{\norm}[2][\VectorSpace]{{\left\| #2 \right\|}_{#1}}
\newcommand{\ip}[3][\VectorSpace]{{{\langle #2, #3 \rangle}_{#1}}}
\newcommand{\AffineTransformations}[1]{{\mathrm{Affine} (#1)}}
\newcommand{\Ball}[3][\VectorSpace]{{B_{#1} (#2, #3)}}
\newcommand{\BesselPotential}[2][\Group]{{(I - \Laplacian[#1])^\frac{#2}{2}}}
\newcommand{\Character}[1]{{\chi_{#1}}}
\newcommand{\DifferenceOperator}[2][\Group]{{\Delta^{#1}_{#2}}}
\newcommand{\EquivalenceClass}[2]{{{[#2]}_{#1}}}
\newcommand{\Fourier}[1][\Group]{\mathcal{F}_{#1}}
\newcommand{\Group}{G}
\newcommand{\Hil}{\mathcal{H}}
\newcommand{\Hilbert}[2]{{\mathfrak{H}^{#1}_{#2}}}
\newcommand{\HilbertRep}[1]{{\mathfrak{H}_{#1}}}
\newcommand{\InverseFourier}[1][\Group]{\mathcal{F}^{-1}_{#1}}
\newcommand{\CompactGroup}{K}
\newcommand{\HilbertSchmidt}[1]{{\mathcal{HS} \left(#1\right)}}
\newcommand{\Id}[1]{{I_{#1}}}
\newcommand{\IsotropySubgroup}[2]{{{#1}_{#2}}}
\newcommand{\JapaneseBracket}[2]{{\langle #2 \rangle}_{\dualGroup{#1}}}
\newcommand{\Kronecker}[2]{\delta_{#1,#2}}
\newcommand{\Lebesgue}[2]{{L^{#1} (#2)}}
\newcommand{\LeftDifferentialOperatorFirstOrder}[1]{{#1}_L}
\newcommand{\LieAlgebra}{\mathfrak{g}}
\newcommand{\LieBracket}[2]{[#1, #2]}
\newcommand{\Lin}[1]{{\mathcal{L} (#1)}}
\renewcommand{\Laplacian}[1][\Group]{{\mathcal{L}_{#1}}}
\newcommand{\MotionGroup}[1]{{\mathrm{SE} (#1)}}
\newcommand{\OrthogonalGroup}[1]{{\mathrm{O} (#1)}}
\newcommand{\Plancherel}[1]{\mu_{\dualGroup{#1}}}
\newcommand{\Polynomials}[1]{{\mathrm{Pol}_{#1}}}
\newcommand{\LeftQuotient}[2]{{{#1} \backslash{} {#2}}}
\newcommand{\RightQuotient}[2]{{{#1} \slash{} {#2}}}
\newcommand{\Rep}[1]{\xi^{#1}_\Group}
\newcommand{\RightLaplacian}[1][\Group]{{\tilde{\mathcal{L}}_{#1}}}
\newcommand{\SmoothFunctions}[1]{{C^\infty(#1)}}
\newcommand{\Schwartz}[1]{{\mathcal{S} (#1)}}
\newcommand{\SpecialOrthogonalGroup}[1]{{\mathrm{SO} (#1)}}
\newcommand{\VectorSpace}{V}

\DeclareMathOperator{\Aut}{Aut}
\DeclareMathOperator{\End}{End}
\DeclareMathOperator{\Hom}{Hom}
\DeclareMathOperator{\Span}{span}
\DeclareMathOperator{\tr}{tr}
\DeclareMathOperator{\order}{order}
\DeclareMathOperator{\supp}{supp}

\newcommand{\texToLua}[1]{\luatexluaescapestring{\unexpanded{#1}}}
\directlua{%
--beginlua--
function derivative(f, string, evaluation)
    local denominator, total_order, total_order_numerical = '', '', 0;

    -- string = argument, argument, ...
    -- argument = variable^order or variable
    for argument in string.gmatch(string, '([^,]+)') do
        local variable, order = argument, 1
        if string.find(argument, '%^') then
            variable, order = argument:match('([^%^]*)%^([^%^]*)')
        end
        -- If integer, add to 'numerical' total, otherwise, concatenate directly to total_order
        if tonumber(order) ~= nil then -- if is number
            total_order_numerical = total_order_numerical + tonumber(order)
        else
            total_order = total_order..(total_order == '' and '' or ' + ')..order
        end
        local order_string = ((tonumber(order) == nil or tonumber(order) > 1) and '^{'..order..'}' or '')
        denominator = denominator..'\\partial '..variable..order_string..' '
    end

    -- Append numerical order if necessary
    if trim(total_order) == '' then
        total_order = (total_order_numerical > 1) and total_order_numerical or ''
    else
        total_order = total_order..((total_order_numerical > 0) and ' +'..total_order_numerical or '')
    end

    -- If non-empty, append put in superscript
    if trim(total_order) ~= '' then
        total_order = '^{'..total_order..'} '
    end

    local output = '\\frac{\\partial '..total_order..f.. '}{'..denominator..'}'

    -- Appends evaluation if necessary
    if trim(evaluation) ~= '' then
        output = '\\left. '..output..' \\right|_{'..evaluation..'}'
    end

    tex.sprint(output)
end
--endlua--
}
\DeclareDocumentCommand \D{O{}mD<>{}}{%
    \directlua{derivative("\texToLua{#1}", "\texToLua{#2}", "\texToLua{#3}")}
}

% Sets
\newcommand{\C}{\mathbb{C}}
\newcommand{\N}{\mathbb{N}}
\newcommand{\R}{\mathbb{R}}
\newcommand{\T}{\mathbb{T}}

% Constants
\newcommand{\e}{e}
\newcommand{\turn}{2 \pi}
\renewcommand{\i}{i}

% Pseudo-differential calculus
\newcommand{\SmoothSymbols}[1][\Group]{{S^{-\infty} (#1)}}
\newcommand{\SymbolSemiNorm}[4][\Group]{\norm[S^{#2}_{#3}{#1}]{#4}}
